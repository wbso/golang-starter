// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users WHERE deleted_at IS NULL
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    username,
    email,
    password_hash,
    full_name,
    created_by,
    updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	Username     string         `json:"username"`
	Email        string         `json:"email"`
	PasswordHash string         `json:"password_hash"`
	FullName     sql.NullString `json:"full_name"`
	CreatedBy    uuid.NullUUID  `json:"created_by"`
	UpdatedBy    uuid.NullUUID  `json:"updated_by"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.FullName,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const disableUser = `-- name: DisableUser :one
UPDATE users
SET
    is_disabled = true,
    updated_by = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at
`

type DisableUserParams struct {
	ID        uuid.UUID     `json:"id"`
	UpdatedBy uuid.NullUUID `json:"updated_by"`
}

func (q *Queries) DisableUser(ctx context.Context, arg DisableUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, disableUser, arg.ID, arg.UpdatedBy)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const enableUser = `-- name: EnableUser :one
UPDATE users
SET
    is_disabled = false,
    failed_login_attempts = 0,
    locked_until = NULL,
    updated_by = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at
`

type EnableUserParams struct {
	ID        uuid.UUID     `json:"id"`
	UpdatedBy uuid.NullUUID `json:"updated_by"`
}

func (q *Queries) EnableUser(ctx context.Context, arg EnableUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, enableUser, arg.ID, arg.UpdatedBy)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at FROM users
WHERE email = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at FROM users
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at FROM users
WHERE username = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const incrementFailedLoginAttempts = `-- name: IncrementFailedLoginAttempts :one
UPDATE users
SET
    failed_login_attempts = failed_login_attempts + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at
`

func (q *Queries) IncrementFailedLoginAttempts(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, incrementFailedLoginAttempts, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at FROM users
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.FullName,
			&i.IsDisabled,
			&i.IsEmailVerified,
			&i.FailedLoginAttempts,
			&i.LockedUntil,
			&i.LastLoginAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockUser = `-- name: LockUser :one
UPDATE users
SET
    locked_until = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at
`

type LockUserParams struct {
	ID          uuid.UUID    `json:"id"`
	LockedUntil sql.NullTime `json:"locked_until"`
}

func (q *Queries) LockUser(ctx context.Context, arg LockUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, lockUser, arg.ID, arg.LockedUntil)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const restoreUser = `-- name: RestoreUser :one
UPDATE users
SET
    deleted_at = NULL,
    is_disabled = false,
    failed_login_attempts = 0,
    locked_until = NULL,
    updated_by = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NOT NULL
RETURNING id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at
`

type RestoreUserParams struct {
	ID        uuid.UUID     `json:"id"`
	UpdatedBy uuid.NullUUID `json:"updated_by"`
}

func (q *Queries) RestoreUser(ctx context.Context, arg RestoreUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, restoreUser, arg.ID, arg.UpdatedBy)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const softDeleteUser = `-- name: SoftDeleteUser :one
UPDATE users
SET
    deleted_at = CURRENT_TIMESTAMP,
    updated_by = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at
`

type SoftDeleteUserParams struct {
	ID        uuid.UUID     `json:"id"`
	UpdatedBy uuid.NullUUID `json:"updated_by"`
}

func (q *Queries) SoftDeleteUser(ctx context.Context, arg SoftDeleteUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, softDeleteUser, arg.ID, arg.UpdatedBy)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateLastLogin = `-- name: UpdateLastLogin :one
UPDATE users
SET
    last_login_at = CURRENT_TIMESTAMP,
    failed_login_attempts = 0,
    locked_until = NULL
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at
`

func (q *Queries) UpdateLastLogin(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, updateLastLogin, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updatePassword = `-- name: UpdatePassword :one
UPDATE users
SET
    password_hash = $2,
    updated_by = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at
`

type UpdatePasswordParams struct {
	ID           uuid.UUID     `json:"id"`
	PasswordHash string        `json:"password_hash"`
	UpdatedBy    uuid.NullUUID `json:"updated_by"`
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updatePassword, arg.ID, arg.PasswordHash, arg.UpdatedBy)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
    username = COALESCE($2, username),
    email = COALESCE($3, email),
    full_name = COALESCE($4, full_name),
    updated_by = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at
`

type UpdateUserParams struct {
	ID        uuid.UUID      `json:"id"`
	Username  string         `json:"username"`
	Email     string         `json:"email"`
	FullName  sql.NullString `json:"full_name"`
	UpdatedBy uuid.NullUUID  `json:"updated_by"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.FullName,
		arg.UpdatedBy,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const verifyEmail = `-- name: VerifyEmail :one
UPDATE users
SET
    is_email_verified = true,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, username, email, password_hash, full_name, is_disabled, is_email_verified, failed_login_attempts, locked_until, last_login_at, created_by, updated_by, created_at, updated_at, deleted_at
`

func (q *Queries) VerifyEmail(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, verifyEmail, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.IsDisabled,
		&i.IsEmailVerified,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
